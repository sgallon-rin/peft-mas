#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
from typing import List, Dict
from rouge_score import rouge_scorer, scoring


ROUGE_KEYS = ["rouge1", "rouge2", "rougeL"]


# def calculate_rouge(output_lns: List[str], reference_lns: List[str], use_stemmer=True) -> Dict:
#     scorer = rouge_scorer.RougeScorer(ROUGE_KEYS, use_stemmer=use_stemmer)
#     aggregator = scoring.BootstrapAggregator()
#
#     for reference_ln, output_ln in zip(reference_lns, output_lns):
#         scores = scorer.score(reference_ln, output_ln)
#         aggregator.add_scores(scores)
#
#     result = aggregator.aggregate()
#     return {k: round(v.mid.fmeasure * 100, 4) for k, v in result.items()}


def calculate_multi_rouge(output_lns: List[str], reference_lns: List[str], use_stemmer=True, lang="english") -> Dict:
    """
    multilingual ROUGE score
    ref: https://github.com/csebuetnlp/xl-sum/tree/master/multilingual_rouge_scoring
    Supported language names for stemming:
    - bengali, hindi, turkish, arabic, danish, dutch, english, finnish, french, german, hungarian, italian, norwegian,
      portuguese, romanian, russian, spanish, swedish
    Supported language names for word segmentation:
    - chinese, thai, japanese, burmese
    """
    scorer = rouge_scorer.RougeScorer(ROUGE_KEYS, use_stemmer=use_stemmer, lang=lang)
    aggregator = scoring.BootstrapAggregator()

    for reference_ln, output_ln in zip(reference_lns, output_lns):
        scores = scorer.score(reference_ln, output_ln)
        aggregator.add_scores(scores)

    result = aggregator.aggregate()
    return {k: round(v.mid.fmeasure * 100, 4) for k, v in result.items()}


# Copied from https://github.com/csebuetnlp/CrossSum/blob/main/seq2seq/sentence_splitter.py
import re

try:
    import nltk

    NLTK_AVAILABLE = True
except (ImportError, ModuleNotFoundError):
    NLTK_AVAILABLE = False


def add_newline_to_end_of_each_sentence(x: str) -> str:
    """This was added to get rougeLsum scores matching published rougeL scores for BART and PEGASUS."""
    re.sub("<n>", "", x)  # remove pegasus newline char
    assert NLTK_AVAILABLE, "nltk must be installed to separate newlines between sentences. (pip install nltk)"
    return "\n".join(nltk.sent_tokenize(x))


# Copied from https://github.com/csebuetnlp/CrossSum/blob/main/seq2seq/utils.py
def extract_rouge_mid_statistics(dct):
    new_dict = {}
    for k1, v1 in dct.items():
        mid = v1.mid
        new_dict[k1] = {stat: round(getattr(mid, stat), 4) for stat in ["precision", "recall", "fmeasure"]}
    return new_dict


def calculate_rouge(
        pred_lns: List[str],
        tgt_lns: List[str],
        use_stemmer=True,
        rouge_keys=ROUGE_KEYS,
        return_precision_and_recall=False,
        bootstrap_aggregation=True,
        newline_sep=True,
        rouge_lang=None,
) -> Dict:
    """Calculate rouge using rouge_scorer package.

    Args:
        pred_lns: list of summaries generated by model
        tgt_lns: list of groundtruth summaries (e.g. contents of val.target)
        use_stemmer:  Bool indicating whether Porter stemmer should be used to
        strip word suffixes to improve matching.
        rouge_keys:  which metrics to compute, defaults to rouge1, rouge2, rougeL, rougeLsum
        return_precision_and_recall: (False) whether to also return precision and recall.
        bootstrap_aggregation: whether to do the typical bootstrap resampling of scores. Defaults to True, if False
            this function returns a collections.defaultdict[metric: list of values for each observation for each subscore]``
        newline_sep:(default=True) whether to add newline between sentences. This is essential for calculation rougeL
        on multi sentence summaries (CNN/DM dataset).

    Returns:
         Dict[score: value] if aggregate else defaultdict(list) keyed by rouge_keys

    """
    # logger.info("Rouge lang: " + str(rouge_lang))
    print("Rouge lang: " + str(rouge_lang))
    scorer = rouge_scorer.RougeScorer(
        rouge_keys, lang=rouge_lang,
        use_stemmer=use_stemmer
    )
    aggregator = scoring.BootstrapAggregator()
    for pred, tgt in zip(tgt_lns, pred_lns):
        # rougeLsum expects "\n" separated sentences within a summary
        if newline_sep:
            pred = add_newline_to_end_of_each_sentence(pred)
            tgt = add_newline_to_end_of_each_sentence(tgt)
        scores = scorer.score(pred, tgt)
        aggregator.add_scores(scores)

    if bootstrap_aggregation:
        result = aggregator.aggregate()
        if return_precision_and_recall:
            return extract_rouge_mid_statistics(result)  # here we return dict
        else:
            return {k: round(v.mid.fmeasure * 100, 4) for k, v in result.items()}

    else:
        return aggregator._scores  # here we return defaultdict(list)


def sep_list(lst, sublist_len):
    return [lst[i: i+sublist_len] for i in range(0, len(lst), sublist_len)]



